% TSPARSE   Flexibly extracts information from sequences of time-stamped%   data found by TSmatch. Usually called as a helper function by%   TStrialstat or TSsessionstat.  The computations are done either by%   some (usually simple) Matlab code passed in as text or by a custom%   helper function (for more complex computations)%   %   TSparse is unlike most TS functions in that it does not have a field%   name as its first argument, because it is usually called by other TS%   functions that do have fields into which they put the arrays delivered%   to them by TSparse%%   Syntax: result = TSparse(tsdata, mcode, matchcodes);%%       or: result = TSparse(tsdata, funhand, matchcodes); %%   tsdata is a chunk of time-stamped data (that is, a 2-col array with%   time stamps in the first column and numerical event codes in the 2nd%   column; mcode is some executable Matlab code enclosed in single quotes.%   It MUST be of the form "result = morecode", where "morecode" is some%   Matlab code that yields either an empty result or a row vector of%   unvarying length. Also, every non-empty result must NOT have nan as the%   first value in the row. Terminate the matlab code with a ';' (inside%   the single quotes. If you do not, every result will be displayed in the%   command window, greatly slowing execution.%    %   Instead of mcode, the 2nd argument may be the handle to a custom helper  %   function. The custom helper function must return either an empty output%   or an output a row vector of a fixed length. And when it returns an%   non-empty row vector, the first value in the row must NOT be nan.%%   PRIVILEGED WORDS: The words "time," "match," "starttime," and "endtime"%   are privileged; they refer to variables internal to TSparse, which%   variables may be referred to by the user's mcode: time is%   a vector variable whose values specify the session times for the%   positive events in whichever matchcode generated the current match;%   match is an integer specifying which of (what may be) several%   different matchcode sequences generated the current match; startime%   is the time of the first event in the tsdata passed in;endtime is the%   time of the last event . Because TSparse always computes values for%   these variables, they may be passed in to the user's custom helper%   function. See the Chapter on TSparse in the Manual for further%   explanation and for illustrative examples.   %%   See also TSMATCH, TSSESSIONSTAT, TSTRIALSTATfunction result1_tsparse = TSparse(tsdata_tsparse,code_tsparse,varargin)%%   Below you will notice that alot of variables have '_tsparse' appended%   to the end of them. This is to prevent collisions when using "eval" in%   this functions workspace. For example, if someone had a for loop in%   their eval code, and if it was Adam, and he uses "lp" for every loop%   variable, (or if it was me, and I use "x" for every loop variable)%   then there would be a big problem because lp would be overwritten when%   the code is evaluated. Adding _tsparse after the codes prevents this%   collision danger because no one in their right mind would use%   lp_tsparse as a variable name.%%   The varargin argument only ever contains the cell array with the match%   codes. It was originally written as a varargin argument, because we%   thought that the power user might want sometime to supply arguments in%   addition to the matchcodes when using a custom function in place of the%   mcode. At this time (11/2014), I am tempted to rename this input%   argument matchcodes. However, this function has worked without problem%   for years, so I have decide to confine my revision to replacing the%   code now commented out at Line 83, which was pretty crazy. This also%   required changing the last argument of the call at L 90 to 'matchcodes'TSdeclareeventcodes;           % Declare event codes so that they can be used in evalcode.result1_tsparse=[];starttime=tsdata_tsparse(1,1);    % Start timeendtime=tsdata_tsparse(end,1);    % End timeif nargin < 3    error ('Match codes not supplied to TSparse, check the documentation.');endif numel(varargin) == 1 && iscell(varargin{1})    % if the varargin cell array only has one cell and the contents of that    % cell is a cell. This is for the case that a single vector is passed    % in as a cell array (a varargin).        varargin = varargin{1}; % the once cell in varargin now contains just a     % vector; matchcodes must be a cell array in which each cell contains one    % vector; a cell in the matchcodes cell array cannot contain another    % cell array% The 3rd input argument was made a varargin on the% assumption that we might someday write code that would allow additional% arguments to be passed to the helper function. Now (4/12/2016), I am% attempting to do that--CRG% If the 3rd argument to TSparse is a cell array, then that cell array then% that cell array becomes the contents of the 1st cell of cell of varargin.% If there is a 4th argument in the call to TSparse, then it becomes the% contents of the 2nd cell of varargin, and so on.endmatchcodes = varargin;[matches_tsparse,bindings_tsparse]=TSmatch(tsdata_tsparse,matchcodes);  if ischar(code_tsparse)        % On 09/03/2014, I changed the following code so as to implement    % initialization of the result1_parse array, to speed up processing.    % This initialization is tricky because one cannot know in advance how    % many columns there should be in the initial array        result1_tsparse = nan(length(matches_tsparse),1); % preliminary initialization    % This may be revised by adding columns the first time that the    % evaluation of code_tsparse gives a non-empty result        for lp_tsparse = 1:length(matches_tsparse); % For each successful match                match=matches_tsparse(lp_tsparse); % because match may appear as a        % variable in code_tsparse                time = tsdata_tsparse(bindings_tsparse{lp_tsparse}, 1); % because        % a time vector is presumed in code_tsparse                result=[]; % because code_tsparse always has result as its output                eval(code_tsparse); % evaluating the passed in code; this always        % yields a (possibly empty) row vector                if length(result) > size(result1_tsparse,2) % if the evaluation of            % the code yields a row vector longer than the nan array            % produced on initialization is wide. This should happen at            % most once                        result1_tsparse = [result1_tsparse ...                nan(length(result1_tsparse),length(result)-1)];            % This augmentation of the width of the nan array should happen            % at most once, because every evaluation of code_tsparse that            % does not yield an empty result should yield a row vector of the            % same length as every other non-empty evaluation                    end                result1_tsparse(lp_tsparse,:) = result; % replaces a row of nans in        % result1_tsparse with the results generated by evaluating        % code_tsparse    end    elseif isa(code_tsparse, 'function_handle') % if TSparse is to call a    % helper function rather than evaluate passed-in code        result1_tsparse = nan(length(matches_tsparse),1); % preliminary initialization    % This may be revised by adding columns the first time that the    % the code_tsparse helper function returns a non-empty results        for lp=1:length(matches_tsparse);  % For each successful match                match=matches_tsparse(lp); % the integer specifying which of the        % matchcodes generated this match                time = tsdata_tsparse(bindings_tsparse{lp}, 1); % vector of the        % session times for the events in a single match within the chunk        % of tsdata that TSparse has been handed        result = code_tsparse(match, time, starttime, endtime);        % the call to the helper function        % NB starttime is the first session time in the chunk of tsdata         % passed to TSparse and endtime is the last session time in that        % chunk. The values for these privileged variables are set at the        % beginning of this function                if length(result) > size(result1_tsparse,2) % if the helper function            % returns a row vector longer than the nan array            % produced on initialization is wide. This should happen at            % most once.                        result1_tsparse = [result1_tsparse ...                nan(length(result1_tsparse),length(result)-1)];            % This augmentation of the width of the nan array should happen            % at most once, because every evaluation of code_tsparse that            % does not yield an empty result must yield a row vector of the            % same length as every other non-empty evaluation         end                        result1_tsparse(lp,:) = result;    endendresult1_tsparse(isnan(result1_tsparse(:,1)),:) = []; % deleting the rows% that did not have a result